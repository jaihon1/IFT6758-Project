---
layout: post
title: IFT6758 Milestone 1
---

## Warmup
Analyzing sports is becoming more and more valuable with the growth of various sensors and technology. In the case of hockey in partiular, be it a goalie or skater, there are certainly a wide range of metrics available for us to analyze the performace of hockey player.

### Question 1
In the case of hockey goalies, although using the Save Percentage (SV%) is a relatively good metric to measure a goalie's performance, it is certainly not without a set of limitations. The main one being the number of games played by the goalies.

> Save percentage (often known by such symbols as SV%, SVS%, SVP, PCT) is a statistic in many sports that track saves as a statistic. In ice hockey and lacrosse, it is a statistic that represents the percentage of shots on goal a goaltender stops. It is calculated by dividing the number of saves by the total number of shots on goal (From Wikipedia, Save Percentage).

*More information can be found here [save percentage](https://en.wikipedia.org/wiki/Save_percentage).*

For example, if we compare a goalie who only played one game to another goalie who played 50 games during the season. If the goalie who played the single game ended the game with zero goals conceded, he will have an average SV% of 100.00. In contrast, the goalie who played 50 games and has an average SV% of 95.00 will look like he was worst than the one with 100.00 SV%. Where in reality, the goalie who played only one game might had an "easier game" or even possibly only had to save a very low amount of low quality shots. Here is a visualization of the top 20 nhl goalies from the 2017-2018 season solely based on their save percentage metric:

![Top 20 Goalies 2017](/public/top-goalies-nomask.png)

Save percentage is probably the best metric we have for capturing a player's ability to stop shots but it is swamped by random variance, team effects and potentially sample size issues that kill any hope at meaningful confidence intervals. It leads to very little repeatability in goaltender performance, which makes it a struggle to forecast what many players will do in upcoming years.
The rule of thumb is that you would like to have a goalie’s save percentage to be 0.915% or higher. The league average is 0.910% *[(Reference)](https://www.gaimday.com/blog/save-percentage/).*


A better metric would be for instance to set an inclusion criteria based on a preset threshold of games played for each goalie. For example, setting a threshold of at least 10 games played before even considering the goalie's performance on the 'Top goalies' analysis. This would be a way to control the 'low number of shots received with high number of saves' bias. Another, slighlty different inclusion criteria could be to simply set a threshold for the number of shots received by each goalie.

### Question 2
Here is a filtered visualization where we applied a mask that excluded goalies that had less than 10 games played during that same season:

![Top 20 Goalies 2017](/public/top-goalies-mask.png)


### Question 3
There are many features that could optimise the estimation of a goalie's performance. Save Percentage, although limited in it's interpretation is actually quite relevant when used appropriately and within it's set of limitations. Here are a couple of features that could potentially be useful in determining a goalie's performance.

A useful feature could be the SV% for each of the 3 periods. This could be an indicator of performance in function of time, although this feature would again be subject to similar limitation as previously discussed. On the other hand, if the inclusion criterias are set in a way to reduce the bias discussed previously in question 1, then this feature could be quite interesting to measure if a goalie's performance decreases, remains stable, or increases as the game progresses.

Another interesting variation of the save percentage would be to observe and experiment with is the goalie's SV% during different states of a game. Such as the SV% when the goalie's team is leading, equal or trailling.

Taking a look at where (in terms of a 2D space representing the surface of the goal's entrance) the goalie seems to be the most efficient in saving/conceding shots could definitly be a useful feature to highlight the strengths/weaknesses of a goalie's performance. If for instance most shots a goalie conceeds are located on the top-right space of the grid, then that information could definitly be useful in different ways. The same type of information could be used but instead of using the 2D grid as a representation of the goal, it could be the location of the shot's origin point on the ice. This would give a useful indicator of a goalies performance in terms of where he/she is receiving a shot from on the ice. These two features could also be combined into one. It would also be relevant to use a feature measuring the goalie's performance in 1 v 1 scenarios for instance in the penalty shots scenario.

Also for the longest time, the most important stat for an NHL goalie was his Goals Against Average (“GAA”) which is simply the average number of goals let in per game. However, as the stats world developed GAA came to be seen as a better indicator of team performance than individual performance.

## Data Acquisition
The main objective here is to download hockey games through the NHL API, or simply load them if they have already been downloaded. For this purpose, we created a class called GamesInfo. Depending on the state of the local data files (whether the files have been downloaded or not), it will download or load all the games' information taken from the json files in a dictionary where the keys are the season and the values are lists of dictionaries containing the information of each game.

In order to have a functional class, we will need the following libraries:

```python

from glob import glob
import requests
import json
import os

```

As shown by the following code, to instantiate a GamesInfo object, we need to pass the season or a list of seasons that we want, either as a string, int, a list of strings or a list of ints.


```python
class GamesInfo:
    def __init__(
        self,
        season,
        filepath=os.path.join(os.path.dirname(__file__)),
        games_info=None):
```


The second argument is the filepath
where to download the files or the filepath where the files have been previously downloaded. The third argument is games_info(dictionary of all the
games information) and is None by default. This is used if you want to instantiate an object of GamesInfo with a
dictionary that already contains all the information about the games instead of downloading them or loading them from
files.

Once the instance is created with the arguments, the class GamesInfo then generates an object
that contains all of the regular and playoff games from the specified seasons.

In our case, we only need the Download method. Essentially, it downloads and saves the json files from the corresponding seasons in the specified filepath and then returns a list of all the information about all the games of the season.
More specifically, for this to work, it first gets all of the games id from the NHL API
using the arguments schedule and specifying the season and game types (regular and playoff). This return a json file with
a list of general information about the games from the specified season. From this, it gets all of the needed games id
and iterate over them to get their specific information from the API in the form of a json file. These are the files that end up being saved.

The class also has the load method which loads the json files already downloaded, the add_season method which adds
games from a new season in the object and the ```__add__``` method which implements the sum operator for the class in order
to combine two GamesInfo together. The ```__add__``` method returns a new GamesInfo object instance which contains all of the seasons from the two GamesInfo combined. If they share some seasons, only one will be kept, meaning that the new object
doesn't contain repetitions.

```python
def add_season(self, season):
```

```python
def __add__(self, other):
```

#### Example on how to use it:
If you want to download the games from the seasons 2016-2017 and 2017-2018, you could simply write:
```python
your_games = GamesInfo([2016,2017], 'filepath_where_you_want_to_save')
```

If, later on, you would like to add the games from 2018-2019, you could use the add_season method like this:

```python
your_games.add_season(2018)
```

To add a new season, it is also possible to create a new GamesInfo object and sum it with ``your_games``:
```python
new_games = GamesInfo(2018, 'filepath_where_you_want_to_save')
all_seasons = your_games + new_games
```

## Interactive Debugging Tool
The interactive debugging tool can be found in [project/notebooks/Interactive debugging tool](../../project/notebooks/Interactive debugging tool.ipynb).

Here are pictures of it:
![bonus_applet.png](/public/bonus_applet.png)
![bonus_applet_json.png](/public/bonus_applet_json.png)

*How to use it and what does it do:*

Let's try to replicate the example shown on the pictures above. First thing to do would be to select the season. For example, if you would like a game from season 2019, you could choose
2019 from the dropdown as shown on the picture above. Once this is done, you can choose either the regular games or the
playoffs. Regular was selected in this example. The next step would be to slide the games' id slider to select a specific
game from the regular season of 2019. 2019020609 was chosen here. Below the slider is printed the general information about the game like who played
and how many goals each team made. Finally, you can slide the event slider to explore all of the events from the
selected game. The events will be shown on the rink below the slider. In addition to the rink, the event information like
who did what, when, how, etc., will be printed below as is shown on the second picture above.


## Tidy Data
Here is a head display of the dataframe generated by aggregating all relevant games for all seasons ranging from 2016 to 2020:
![Dataframe all seasons](/public/df_screenshot.png)

### Strength Feature
Looking deeper into the API, we can observe that the *strength* feature is not always available. Only a *Goal* event has a property strength. In the future, there are a couple of ways we could associate the strength feature with the *Shot* or any other event.

#### Option 1
One way to implement the strength feature to SHOTS as well as the GOAL event would be to use the information given by the datetime element of the event: PENALTY, as demonstrated below:

```python
"result" : {
    "event" : "Penalty",
    "eventCode" : "OTT47",
    "eventTypeId" : "PENALTY",
    "description" : "Mark Borowiecki Fighting against Matt Martin",
    "secondaryType" : "Fighting",
    "penaltySeverity" : "Major",
    "penaltyMinutes" : 5,
},
"about" : {
    "eventIdx" : 74,
    "eventId" : 47,
    "period" : 1,
    "periodType" : "REGULAR",
    "ordinalNum" : "1st",
    "periodTime" : "13:25",
    "periodTimeRemaining" : "06:35",
    "dateTime" : "2016-10-12T23:42:40Z",
    "goals" : {
    "away" : 1,
    "home" : 2,
}
```

For instance, when a SHOT event is registered for player X of team A, one could iterate over each PENALTY event of this game that is at an inferior datetime from the SHOT event and that includes the SHOT event datetime when the penaltyMinutes value is added to it. Then, it would incrementally add + 1 to a counter that represents the number of players on the bench if the previous condition is met. By substracting the max number of players (6) by this counter value, one would end up with the number of players on ice (NoPoI) at that event. Once this is done for both teams, by comparing the NoPoI of each team at the event timepoint, one would be able to determine if the SHOT, or GOAL was at strength: Powerplay , Even or  Short Handed. In addition to that, one could also have the value of this strength feature (i.e: SHOT, Powerplay, 5-3).

#### Option 2
An alternative would be to use the power of our data structure to solve this problem. Because the game events are recorded and stored chronologically, we can use this to build an internal state of "team strength" for each team that is currently playing using the Penalty events and the periodTime property from our raw data.

For every penalty that creates a short-handed situation, we would have to update our current state of the team's penalty tracking component by storing its id, timestamp and duration. Then as the games goes, for each event, we use the periodTime feature of this event to update the active penalties that we are currently tracking (for both teams). This will allow us to update the duration left to a particular penalty, which is critical because a penalty that modifies the strength of a team will always have an end, and therefore our penalty tracking system must have a way to be made aware when a penalty ends.

That way, for any given event that happens throughout a game, we would be able to know the strength component of each team at any precise moment. We could then use this to add the "strength" feature, not only to the shot event, but any other event as well.

### Additional Features
An interesting feature that could be added would be to categorize the type of GOAL that was scored ('Goal type'). For example, as a rebound  GOAL or not. To implement this, one could, for each GOAL event, identify if a SHOT was taken at a specific timedelta interval between the SHOT and the GOAL. If that criteria is met, a "Rebound" observation could be added to the 'Goal type' feature. One could also identify a 'Lightning' Goal type if it was scored under a specific amount of time between the goal and a faceoff, and if that faceoff was located on the scoring team's ice. This could be used by selecting a GOAL event with: 1) A faceoff event close enough in terms of timedelta; 2) With x coordinates representing the scoring team's ice location.

Another feature could be goals or chances created by a team on the counter-attack. We could generate this feature using the raw data in the following way: we could first look at when a goalie saves the puck or when a defending player blocks a shot, and then we could check if there is another event right after this one that leads to a goal in the other end of the rink (in a predefined time window of 5-10 seconds). This way, we would be able to get a sense of what represents a goal scored on the counter-attack.

## Simple Visualization
For our analysis, we have chosen the season 2016. The most dangerous type of shot in the 2016 Season is the
deflected type with a Percentage of scoring shots of 16.5 % followed by the Tip-In with
15.2%.

![img_2.png](/public/img_2.png)

As for the most common type of shot in the season 2016, it is the Wrist Shot with a total of 38 056 shots
followed by the Slap Shot with 12 691 shots which can be seen on the bar plot showing the number of shots for each type as well as the number of goals.
![img_1.png](/public/img_1.png)

![img_3.png](/public/img_3.png)

The relationship between the distance from which a shot was taken and the probability it was a goal
has been produce in one figure containing 3 plots, one for 2018, one for 2019,
and one for 2020.
The first plot describes the chance of scoring a goal in function of the shot's
distance from the goal for season 2018.  The highest percentage is 20.27 % for the shortest shot distance
interval (1 feet to 5.8 feets), which is logical because it is very close to the net.
Not surprisingly, the percentage slowly decreases the farther we are from the net, and, at 60 feets,
it reaches a percentage of 2.36. Then, the percentage stays between 2 and 5 until it reaches
98 feets.
For the 2019 season (second graph), the highest percentage is 21.93 for the shortest shot distance
interval (1 feet to 5.8 feets), which again is logical because it is very close to the net.
Then at 60 feets, it reaches a percentage of 2.43, and finally the percentage stays between 2 and 6
until the distance of 98 feets.

Finally, for the 2020 season (third plot of the figure), we can observe a similar trend as the other two plots. We have the highest percentage of 22.14 closest to the net and a decreasing percentage of the same order for the following distances.

In other words, there has not been much change about the relationship between the distance from which a shot was taken and the percentage of being a goal over the course of seasons 2018, 2019, and 2020.
For all seasons, it begins with a peak at the shortest distance (very close to the net), reaches one of the
lowest percentage at mid-distance between 45 and 60 feets and then the percentage stays stable with small oscillations until 98 feets.
All our results are consistent with the common rules of Hockey and the common laws of physics that could explain those percentages
variations.

![img_4.png](/public/img_4.png)

According to our results shown in the figure above, the percentage of goals is highest when the shot's distance is
the smallest(between 1 and 8.5 feets) for all kinds of Shot-type.
The percentage keeps decreasing until 50 feets then slightly decreases with small oscillations until 98 feets. This is relatively the same relationship as was shown between a shot's distance and its percentage of being a goal for all shot's types.
On the other hand, the most dangerous types of Shots seems to depend on the distance.
Until 30.8 feets, the most dangerous one is the slap shots, then between 30 and 38 feets, it is the Deflected Shots, then from
38 to 53, it is the Tip-in shots.
After 50 feets, it is sometimes the Deflected types, sometimes the backhand type, and sometimes the wrist-shots.

## Advanced Visualizations: Shot Maps

### Plot
{% include advanced_viz.html %}

### Discussion
There are many interpretations that we can get from the interactive plot shown above. As we can see, the plot's main focus is to show, for specific seasons, a team's shot quality and performance against the league average.

#### Interpretation
The most important interpretation that we can get out of this visualization is the following: What common characteristics does the *top teams* have with each other vs the *bottom teams*. In other words, how can we represent a *good team* and a *bad team* through the analysis of this feature.

#### The logic behind
The logic behind the intuition of this interpretation is simple. In general, better performing teams will generate *better* shooting chances for themselves. What we mean by *better* shooting chances are shots coming mainly from three critical locations near the opponent's goaltender: right in the front of the net (anywhere from around 10 to 20 feet from the goal line), and near both faceoff circles close to the net. Through the data, we can observe that teams like the Colorado Avalanche and the Vegas Golden Knights, that respectively ended the 2020 season as first and second in the final standings (based on *[NHL](https://www.nhl.com/standings/2020/league)*), have an excess shot above average in those three specific locations.


### Study Case: Colorado Avalanche
If we base ourselves solely on the data from the plot, we can conclude that the Colorado Avalanche team from the 2016 season was mostly underperforming because their shots are mostly below the league average in those three critical locations mentioned in the previous section (right in the front of the net, and near both faceoff circles close to the net).

<figure style="display: block;margin-left: auto; margin-right: auto;width:50%;height:50%;">
    <img src="/public/COL-standings-2016.png" alt="Colorado Avalanche 2016 standings">
    <figcaption style="font-size: 12px;text-align: center;">Bottom 5 teams from season 2016, <a href="https://www.nhl.com/standings/2016/league">from NHL.com</a></figcaption>
</figure>

Comparing these results to the Colorado Avalanche team from the 2020 season, we can see a major improvement compared with the league average shots. Especially in those three critical locations. Given these observations, we could see why this team in 2020 was much more successful, where they ended first place overall in the league compared to the 2016 where they ended dead last in the league!

<figure style="display: block;margin-left: auto; margin-right: auto;width:50%;height:50%;">
    <img src="/public/COL-standings-2020.png" alt="Colorado Avalanche 2020 standings">
    <figcaption style="font-size: 12px;text-align: center;">Top 5 teams from season 2020, <a href="https://www.nhl.com/standings/2020/league">from NHL.com</a> </figcaption>
</figure>

In general, this feature does not paint the whole picture about the team's performance, but it gives us a great framework to analyze teams like the Colorado Avalanche from the 2016 and 2020 seasons.


### Study Case: Buffalo Sabres
The main differences between the Buffalo Sabres and the Tampa Bay Lightning's shot maps seem to be that the Lightning do more shots closer
to the goal than the Sabres. The Sabres have generally lower excess shots than the league average in front of the goal and
where they do shoot more than the league average, they are rather spread out in the attacking zone. We could conclude from these
plots that the Sabres have a difficulty penetrating their opponent's defence as opposed to the Lightning. The Lightning, on the other hand, are not only able to shoot
closer to the goal as is shown by a high excess shots on the plots, but most of their excess shots that are positive are also closer to the goal.
In other words, they seem to shoot more often closer to the goal than elsewhere. This might explain the Lightning's success. However, we do not
know if most of these shots are goals. It would be interesting to know how much of these were goals. Nevertheless, in general,
if the Lightning shoots more, their likelihood of scoring  also increases.
